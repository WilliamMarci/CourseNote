# 并行计算

> [!note !tip !important !warning !caution ]

## Introduction

> 正确而高效.

浮点数 (FP8 E4M2, FP8 E5M2, FP16, BF16)

风险在于有向下溢出的风险.

> [!WARNING]
> 浮点数运算不满足结合律

- 适配不同数据
- 适配不同计算技术
- 复杂性优化
- 数据访问效率优化
- 利用率优化

区分:
- 效率Efficiency : 使用的计算量
- 性能Performance: 使用的时间 
- 成本Cost: 求解问题所消耗的资源

区分
- 计算模型: 其量化表示, 数学公式
- 算法: 用计算资源求解的步骤, 伪代码 
- 算法编码: 编码计算机模型, 实际实现

普适计算范式
- 串行计算 以处理器为中心
- 并行计算 以数据为中心

时间资源
- 壁挂时间 wall time 
- 处理器时间 processor time

超标量技术: 多发射指令, 对计算模型的数据处理顺序化.

有些是可以并行运行的(无前缀依赖)


超长指令字技术: IA64 处理器由3条指令组成超指令

程序自动并行化技术

OpenMP, MPI 

## 并行计算体系结构

计算机体系结构(Computer Architecture, CA) 是描述计算系统计算, 组织结构以及实现的一组**规则**和方法.

核函数: 

编写核函数

指令： 计算系统中软件与硬件的接口 (如SSE指令)

Cuda中,kernel函数只能由GPU核心调用.

进程: 程序是以进程的形式分配的资源. 

### 线程进程

用户地址空间: 
- 程序Program code
- 全局变量global data: 进程内所有线程共享, 写程序时已经确定的
- 堆heap: 用于动态分配内存, 临时变量. 写程序时不确定的
- 栈stack: 用于函数调用

操作系统: 
- 核心 <--TCB 线程管理 --> 每一个线程需要一个栈
- PCB 进程管理 --> 每一个进程需要一个堆

![体系结构](image/paraprog/1758097072588.png)

### 从算法/程序性能

体系结构会影响算法的设计: 多个核心时会根据任务的**分解方案**影响算法

会影响程序的性能

异步性是影响程序设计的计算系统关键特征: **部分程序呈现不确定性**

也会有性能不确定.

![1758097939099](image/paraprog/1758097939099.png)

- 基于分治策略的分阶段模型：将数组均分为$(2^p)*T$ 个片段，每个片段包括 $size=N/((2^p)*T)$ 个连续的元素，每阶段处理(2^p)个片段
- 每一阶段查找处理(2^p)个片段，若未找到则继续下一阶段
- 在每个片段内部，任然按照递推模型消除其中的冗余计算

p是每个阶段处理的片度数, T=3时p=1, T=1时p=2, T就是分为多少片, 处理器每阶段处理完(2^p)个片段后再去同步.

T越大,切的越碎, 冗余计算少; p越大, 冗余计算越多

### 并行程序的接口

- 超标量技术: 多发射指令, 对计算模型的数据处理顺序化.
- 向量计算技术: 用向量指令
- 超长指令字技术: IA64 处理器由3条指令组成超指令
- 多核技术: 创建多线程/多进程
- 流式多处理器: 同构多线程 SIMT
- Multiprocessor: 多处理器
- Muiticomputer: 多计算器

flynn分类法
|SISD <\n> Single Instruction Single Data|SIMD <\n> Single Instruction Multiple Data|
|--------------------------------|---------------------------------------|
|MISD <\n> Multiple Instruction Single Data|MIMD <\n> Multiple Instruction Multiple Data|

从软件访问硬件的接口看体系结构


- SISD: 单指令单数据流, 传统计算机, 但是如果有超标量技术, 可以有多个指令并行
- SIMD: 单指令多数据流, 向量计算机, 有多个PU, 同一时刻执行同一指令. (CELL)
- MISD: 多指令单数据流, 少见. google TPU的4*4矩阵乘法
- MIMD: 多指令多数据流, 多处理器 常见的并行计算机都在这里

![MISD](image/paraprog/1758099231130.png)

SIMT是SIMD的一种拓展, 同一时刻它们各自所执行指令的语义相同、分别处理不同的数据，每条指令分别编码被处理数据的地址. 多线程, 但是执行的指令完全一致, 所以指令解码前的过程可以共用, 而且好处是是同步的.


